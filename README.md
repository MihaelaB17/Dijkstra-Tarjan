Inainte de a incepe taskurile, voi citi datele si voi initializa tablourile in care le voi retine.

Task 1:
Pentru a calcula costul minim  voi lua fiecare magazin si voi calcula pentru fiecare. Mai intia voi apela functia Dijkstra pentru drumul dus cat si pentru cel intors si voi retine si costul total in variabila rez. Functia Dijkstra calculeaza costul minim dintre 2 noduri. Aceasta ia 2 cazuri: daca nodul de inceput(init) este mai mic decat nodul final(fin) va parcurge nodurile de la 0 la n-1 si cazul in care init > fin cand va parcurge nodurile de la n-1 la 0. Pentru fiecare caz se va crea matricea m, care retine o valoare maxima preinitializata MAX, daca intre doua noduri i si j nu exista legatura, altfel va retine exact costul drumului respectiv. Vectorl d[i] va retine costurile de pe linia nodului de inceput init (dupa terminarea algoritmului in acest vector se vor afla costurile minime de la nodul de inceput <<init>> pana la fiecare nod din graf), iar vectorul p va si initializat cu valoarea nodului de inceput(la final in acest vector se vor retine parintele fiecarui nod din parcurgerea facuta si va fi ulit la afisarea drumului). Vectorul s retine 0 daca nodul a fost vizitat deja, iar in caz contrar 1.
Pentru fiecare nod nevizitat. Parcurg toate nodurile si actualizez costul minim din vectorul d, dar si nodul pentru care am gasit aceast cost(jmin).
Marchez nodul ca vizitat si mai porgurg o data nodurile pentru a modifica alte evntuale distante mai mici pentru toate nodurile. 
La final rezultatul caurara se va afla pe pozitia fin din vectorul d. 
Acelasi lucru il voi face si pentru celalat caz doar ca parcurgand invers nodurile.
Ulterior voi afisa durumul dus si intors apeland functia drum. 

Task 2:
Mai intai intializez stiva si tablourile ce vor fi folosite in functia Tajan. Pentru a afla componentele tari conexe salvate in vectorul rezultat vom apela functia tarjan functia Tarjan pentru fiecare nod din graf. functia tarjan ajuta la afiserea componentelor conexe. Acestea vor fi retinute intr-o stiva, iar apoi se va extrage element cu element si vor fi salvate nodurile respective intr-un vector. Dupa fiecare componenta conexa gasita se va afisa 0, pentru ca la o ulterioara parcurgere a vectorului in main sa se stie exact ce noduri formeaza fiecare componenta tare conexa. Pentru a introduce nodul in stiva se va pleca dintr-un nod ales u, care va fi pus in stiva si intializata valoarea sa in vectorul disc ce retine daca un nod a fost vizitat sau nu si in vectorul lowlink ce reprezinta nodul cu cea mai mica valoare la care se poate ajunge din nodul u folosind DFS, iar apoi se vor parcurge toate nodurile care se leaga direct de u si se va apela functia recursiv. Dupa ce s-a terminat recursivitatea se vor actualiza valorile vectorilor lowlink cu valoarea minima in functie daca nodul la care am ajuns se afla sau nu deja in stiva. 
La valori de lowlink si disc egale inseamna ca am gasit o componenta coneta si se incepe parcurgerea ei si eliminarea nodurilor care o formeaza din stiva si introducerea acestora in vectorul rez ce va retine toate componentele conexe. 
Pentru a evita depozitele declaram un vector noduri care retine valoare 1 daca nodul respectiv nu este depozit si 0 altfel.
Ulterior se vor scoate elementele sin vector si se vor pune intr-o matrice( pe fiecare linie va fi cate o componenta conexa). Se vor sorta coloanele matricei pentru a avea nodurile in ordine vrescatoare, dar si liniile pentru a afisa mai intai componentele ce contin noduri cu valoarea mai mica, iar apoi cele cu valoare mai mare. Se va parcurge matrice linie cu linie pentru a se afisa componentele tari conexe.( nu-mi da punctaj pe checker la 2 teste din cauza unui spatiu pus in plus) 

